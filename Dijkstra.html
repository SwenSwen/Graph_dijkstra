<!-- 
作者：兰州小红鸡
Dijkstra单源最短路径搜索算法
本代码仅供学习参考
邮箱：flyphp@outlook.com
 -->

<!DOCTYPE html>
<html>
<head>
  <title>Dijkstra单源最短路径算法</title>
  <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
</head>
<body>
  <style type="text/css">
        body,html,div,svg{
          margin:0;
          padding:0; 
       }
       #Wrap{
           position:fixed;
           height: 0%;
           width: 100%;
           user-select:none;
       }
       .itemwrap{
           position: fixed;
           width:50%;
           height:50%;
           left:100px;
           top:100px;
       }
       .item{
           position: absolute;
           left:100px;
           top:100px;
           border:1px solid #333;
           height:50px;
           line-height: 50px;
           width:50px;
           text-align: center;
       }
       .lineWrap{
           position: fixed;
           left:0;
           overflow:visible;
       }
    div.test{
      width: 50px;
      height: 50px;
      background: #49b1f5;
      border-radius: 50%;
      border: 5px solid #34aaf1;
      position: fixed;
      z-index: 9999999;
      font-size: 30px;
      color: #fff;
      text-align: center;
      font-weight: 600;
      /*float: left;*/
    }
    #lineWrap{
           position: fixed;
           overflow:visible;
       }
       .slide{
        position: fixed;
        top: 20px;
        right: 20px;
        height: 85%;
        width: 300px;
        border: 3px solid #49b1f5;
        border-radius: 4px;
        overflow: auto;
       }
       .slide_title{
        font-size: 20px;
        font-weight: 600;
        color: #125;
        background-color: #eeb;
        border-radius: 5px;
       }
       .slide_content{
        font-size: 15px;
        color: #678945;
       }
       .slider_line{
        position: unset;
       }
       .int{
        height: 26px;
        width: 80px;
        border-radius: 3px;
        border: 1px solid #3989c5;
       }
       .control{
        position: fixed;
        margin-top: 10px;
        left: 0px;
        top: 0px;
        width: 80%;
        z-index: 999999999;
        text-align: center;
       }
       .refer{
        height: 30px;
        background: #49b1f5;
        border-radius: 3px;
        border: 1px solid #3989c5;
       }
       .int_num{
        font-size: 22px;
        color: #232323;
        width: 30px;
        height: 30px;
        border-radius: 5px;
        background: #eee;
        text-align: center;
       }
       .changdiv{
        width: 400px;
        height: 250px;
        top: 200px;
        left: 30%;
        border: 4px solid #49b1f5;
        border-radius: 5px;
        text-align: center;
        padding: 20px;
        position: fixed;
        background: #fef;
        display: none;
        z-index: 99999999;
       }
       .tochange{
        margin: auto;
          width: 90px;
          height: 30px;
          border: 3px solid #49b1f5
       }
  </style>
<div class="control">
<div><strong>Dijkstra算法</strong>单源最短路径搜索演示
<a class="github-button" href="https://github.com/flymysql/Graph_dijkstra" data-show-count="true" aria-label="Star flymysql/Graph_dijkstra on GitHub">Star</a><a href="https://me.idealli.com/post/15e41f53.html" target="_blank">详细算法</a><br>输入节点数生成图，点击不同的节点生成链路（链路的权值将会随机生成）<br><strong>点击路径上的权值可更改权值</strong>，输入出发节点，算法演示开始</div>
<input type="button" name="" value="清空页面" class="refer" onclick="cleanele()">
<input type="button" name="" value="清空连线" class="refer" onclick="cleanline()">
<input type="input" name="" id="input_num" value="6" class="int">
<input type="button" name="" value="生成节点" class="refer" onclick="input()">
<input type="input" name="" id="begin" value="v0" class="int">
<input type="button" name="" value="生成最短路径" class="refer" onclick="createPath()">
<input type="button" name="" value="随机生成一个图" class="refer" onclick="randomCreate()">
</div>
<div class="changdiv" id="changdiv">
  输入权值并按确定更改<br>
  <input type="input" name="" id="cnum"><br>
  <br><div class="tochange" id="quxiao" onclick="quxiao()">取消</div><br>
  <div class="tochange" id="onchange" onclick="ok()">确定</div>
</div>
<div class="slide" id="slider">
</div>
<div id="Wrap"></div>
<div id="divele"></div>
<!-- 
作者：兰州小红鸡
Dijkstra单源最短路径搜索算法
本代码仅供学习参考
邮箱：flyphp@outlook.com
 -->

<script type="text/javascript">
var onlink=false;
var onid="";
var MaxvertextType = 100
var gigantic = 99999

var gx=""
var gy=""
var gobj
/*
  Dijkstra算法  
*/
//邻接矩阵
function Mgraph() {
    this.vex=new Array();
    this.edge=new Array();
    this.vexnum=0;
    this.arcnum=0;
};
function getVex(G,x){
    var i=0;
    for(;i<G.vexnum;i++){
    	if(G.vex[i]==x)return i;
    }
    if(G.vex[i]!=x)return -1;
}
//单源最短路径算法
function Dijkstra(g,x){
	cleancolor();
    var vexnum=g.vexnum;
    var vex=getVex(g,x);
    if (vex==-1) return;
    var dist= new Array();
    var path = new Array();
    path[vex]=vex;
    for (var i = 0; i < vexnum; ++i) {
        dist[i]=g.edge[vex][i];
        if(g.edge[vex][i]!=gigantic)path[i]=vex;
    }
    console.log(dist)
    var S = new Array();
    S[vex] = true;
    var dd;
    var dvex=0;
    var j = 0;
    var index=1;
    var descripe=document.getElementById("slider");
    descripe.innerHTML="";
    for (; j < vexnum-1; ++j) {
      setTimeout(function(){
      dd=gigantic;
        for (var i = 0; i < vexnum; ++i) {
            if(dist[i]<dd && !S[i]) {
                dd=dist[i];
                dvex=i;
            }
        }
        if(dd==gigantic){
          for (var i = 0; i < vexnum; ++i) {
              if(dist[i]==dd && !S[i]) {
                  dvex=i;
                  break;
              }
          }
          var str="节点"+g.vex[dvex]+"不可达<br><br>"
          
          descripe.innerHTML = descripe.innerHTML+"<div class=slider_line><div class=slide_title>第"+index+"趟</div><div class=slide_content>"+str+"</div></div>";
      document.body.appendChild(descripe);
      index++;
          S[dvex]= true;
        }
        else{
          var element=document.getElementById(g.vex[dvex]);
            var now=dvex;
            var colo="#"+(Math.round(Math.random()*800)+100);
            element.style.background=colo;
            var str=x+"到"+g.vex[dvex]+"的最短路径："+g.vex[now];
            while(now!=vex){
              var line1=document.getElementById(g.vex[now]+g.vex[path[now]]);
              if (line1==null)
                line1=document.getElementById(g.vex[path[now]]+g.vex[now]);
              //console.log(line1);
              line1.style.stroke=colo;
                now=path[now];
                str=str+"<--"+g.vex[now];
            }
            str=str+"<br>总路程:"+dist[dvex]+"<br><br>";
            descripe.innerHTML = descripe.innerHTML+"<div class=slider_line><div class=slide_title>第"+index+"趟</div><div class=slide_content>"+str+"</div></div>";
        document.body.appendChild(descripe);
        index++;
            S[dvex]= true;
            for (var k = 0; k < vexnum; ++k) {
                if (!S[k]){
                    if (dist[dvex]+g.edge[dvex][k]<dist[k]) {
                        dist[k] = dist[dvex] + g.edge[dvex][k];
                        path[k] = dvex;
                    }
                }
            }         
        }
      },3000*j);
    }
/*
    setTimeout(function(){
        for (var m = 0; m < vexnum; ++m) {
        var nowvex=m;
        var str="\npath:"+g.vex[nowvex];
        while(path[nowvex]!=vex){
            nowvex=path[nowvex];
            str=str+"<-"+g.vex[nowvex];
        }
        str=str+"<-"+g.vex[vex]+"\tdistance:"+dist[m];
        console.log(str);
    }
    },j*3000+2000)
*/
}
//图的初始化
function init(g){
    for(var i=0;i<g.vexnum;i++){
        var temp=[];
        for (var j = 0; j < g.vexnum; ++j) {
            if (i==j) temp[j]=0;
            else temp[j]=gigantic;
        }
        g.edge[i]=temp;
    }
}
//先创建一个全局图
mgraph =new Mgraph;
/*
  图形化部分
*/
　　function getElementLeft(element){
　　　　var actualLeft = element.offsetLeft;
　　　　var current = element.offsetParent;
　　　　while (current !== null){
　　　　　　actualLeft += current.offsetLeft;
　　　　　　current = current.offsetParent;
　　　　}
　　　　return actualLeft;
　　}
　　function getElementTop(element){
　　　　var actualTop = element.offsetTop;
　　　　var current = element.offsetParent;
　　　　while (current !== null){
　　　　　　actualTop += current.offsetTop;
　　　　　　current = current.offsetParent;
　　　　}
　　　　return actualTop;
　　}
  function input() {
    if(mgraph.vexnum==0){
      var oinput=document.getElementById('input_num');
      var num=oinput.value;
      mgraph.vexnum=num;
      init(mgraph);
      //初始化
      for (var i = 0; i < num; i++) {
        var vex="v"+i;
        mgraph.vex[i]=vex;
        var div = document.getElementById("divele");
        var ang=(360/num)*i;
        var x=40 + Math.cos(ang * (Math.PI / 180)) * 30;
        var y=50 + Math.sin(ang * (Math.PI / 180)) * 30;
        //console.log((pai/num)*i)
        
        div.innerHTML = div.innerHTML + "<div id="+vex+" style="+"left:"+x+"%;"+"top:"+y+"%;"+" class="+"test"+" onclick=link(this)>"+vex+"</div>";
        document.body.appendChild(div);
      } 
    }
  }

  function creatline(id1,id2,dis){
      var div = document.getElementById("Wrap");
      var ele1=document.getElementById(id1);
      var x1=getElementLeft(ele1)+25;
      var y1=getElementTop(ele1)+25;
      var ele2=document.getElementById(id2);
      var x2=getElementLeft(ele2)+25;
      var y2=getElementTop(ele2)+25;
      //console.log(y2)
      var size=" x1="+x1+" y1="+y1+" x2="+x2+" y2="+y2;
      div.innerHTML = div.innerHTML+ "<svg class=lineWrap><line id="+id1+id2+" "+size+ " xmlns="+"http://www.w3.org/2000/svg"+" stroke="+"#ddd"+" stroke-width="+5+" marker-end="+"url(#arrow)"+"></line></svg>"+"<div class=int_num style="+"left:"+(x1+(x2-x1)/2.5)+"px;top:"+(y1+(y2-y1)/2.5)+"px;position:fixed;"+" onclick=changnum("+id1+","+id2+",this)>"+dis+"</div>"
      document.body.appendChild(div);
  }

  function link(obj){
    var oid=obj.id;
    
    if(oid!=onid&&onlink){
      
      //生成随机路径长度
      var dis=Math.round(Math.random()*15)+1;
      var x1=getVex(mgraph,oid);
      var y1=getVex(mgraph,onid);
      if(mgraph.edge[x1][y1]==gigantic){
        console.log(dis);
        creatline(oid,onid,dis);
        //无向图的连线
        mgraph.edge[x1][y1]=dis;
        mgraph.edge[y1][x1]=dis;  
      }
      onlink=false;
      onid="";
    }
    else if(!onlink) {
      onid=obj.id;
      onlink=true;
    }
  }
  function createPath(){
    var begin=document.getElementById("begin");
    var bd=begin.value;
    Dijkstra(mgraph,bd);
  }

  function changnum(x,y,obj){
      var ch=document.getElementById("changdiv");
      ch.style.display="block";
      //console.log(x);
      gx=x.id;
      gy=y.id;
      gobj=obj;
  }

  function ok(){
      var changenum=document.getElementById("cnum");
      var cnum=Number(changenum.value);

      if(cnum!=null){
          var x=getVex(mgraph,gx);
          var y=getVex(mgraph,gy);
          mgraph.edge[x][y]=cnum;
          mgraph.edge[y][x]=cnum;  
          console.log(cnum);      
      }
      gobj.innerText=Number(cnum);
      var ch=document.getElementById("changdiv");
      ch.style.display="none";
      changenum.value=""
  }

  function quxiao(){
    var ch=document.getElementById("changdiv");
    ch.style.display="none";
    gx="";
    gy="";
  }

  function cleanline(){
  	var div = document.getElementById("Wrap");
  	div.innerHTML="";
  	init(mgraph);
  	var descripe=document.getElementById("slider");
    descripe.innerHTML="";
  	cleancolor();
  }

  function cleanele(){
  	var div = document.getElementById("divele");
  	div.innerHTML="";
  	cleanline();
  	mgraph.vexnum=0;
  	var descripe=document.getElementById("slider");
    descripe.innerHTML="";
  }

  function cleancolor(){
  	var div=document.getElementById("divele")
  	var ele=div.getElementsByTagName("div")
  	for (var i = ele.length - 1; i >= 0; i--) {
  		ele[i].style.background="#49b1f5";
  	}
  	var line = document.getElementById("Wrap");
  	var linele = line.getElementsByTagName("line")
  	for (var i = linele.length - 1; i >= 0; i--) {
  		linele[i].style.stroke="#ddd";
  	}
  }

  function randomCreate(){
  	cleanele();
  	var inputnum=document.getElementById("input_num");
  	var value=Math.round(Math.random()*4)+4;
  	input_num.value=value;
  	input();
  	for (var i = value - 1; i >= 0; i--) {
  		var lines=Math.round(Math.random()*2)+1;
  		var S=new Array();
  		for (var m = value - 1; m >= 0; m--) S[i]=false;
  		var k=0;
  		for (var j = lines - 1; j >= 0; j--) {
  			for (var n = value - 1; n >= 0; n--) {
  				if (50 > Math.round(Math.random()*100)&&!S[n]) {
  				var x="v"+i;
  				var y="v"+n;
  				var having=document.getElementById(y+x);
  				if(having==null){

  				var fuck=Math.round(Math.random()*15)+1;
  				creatline(x,y,fuck);
  				mgraph.edge[i][n]=fuck;
  				mgraph.edge[n][i]=fuck;
  				}
  				S[n]=true;
  				
  			}
  			}
  		}
  	}
  }

  window.onload=function(){
  	randomCreate();
  }

</script>
<!-- Place this tag in your head or just before your close body tag. -->
<script async defer src="https://buttons.github.io/buttons.js"></script>
</body>
</html>